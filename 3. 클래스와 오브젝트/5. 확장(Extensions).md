# 확장(Extensions)
코틀린은 클래스 상속이나 데코레이터 같은 설계 패턴없이 클래스에 새로운 기능 확장 가능한 기능 제공
## 확장 함수
확장 함수를 선언하려면 리시버(receiver) 타입의 이름을 접두어로 가져아 함   
리시버 타입의 이름은 확장할 타입의 이름

다음 코드는 MutableList<Int>에 swap함수 추가   
```
fun MutableList<Int>.swap(index1: Int, index2: Int) {
  val tmp = this[index1]  // 'this'는 List에 대응
  this[index1] = this[index2]
  this[index2] = tmp
}
```
확장 함수에서 this 키워드는 리시버 객체에 대응한다(리시버 객체는 함수 이름에서 점 앞에 위치한 타입)
```
val l = mutableListOf(1, 2, 3)
l.swap(0, 2)  // 'swap()'에서 'this'는 'l' 값을 갖는다
```
이 함수는 MutableList<T>에도 적용되므로 지네릭으로 만들수 있다
```
fun <T> MutableList<T>.swap(index1: Int, index2: Int) {
  val tmp = this[index1]  // 'this'는 List에 대응
  this[index1] = this[index2]
  this[index2] = tmp
}
```
리시버 타입 식에서 사용할 지네릭 타입 파라미터를 함수 이름 앞에 선언했다
## 정적인 확장 결정
확장이 실제로 확장할 클래스를 변경하지 않는다 / 확장을 정의하는 것은 클래스에 새 멤버를 추가하기보다는,   
그 타입의 변수에 점 부호로 호출할 수 있는 새 함수를 만드는 것이다

확장 함수는 정적으로 전달된다는 점을 강조하고 싶다   
예를 들어, 리시버 타입에 따라 동적으로(virtual) 확장 함수를 결정하지 않는다   
이는 함수 호출 식의 타입에 따라 호출할 확장 함수를 결정한다는 것을 뜻한다   
런타임에 식을 평가한 결과 타입으로 결정하지 않는다. 다음 예를 보자
```
open class C

class D : C()

fun C.foo() = "c"

fun D.foo() = "d"

fun printFoo(c:C) {
  println(c.foo())
}

printFoo(D())
```
이 예는 "c"를 출력한다 / printFoo() 함수의 c 파라미터 타입이 C클래스이므로   
C타입에 대한 확장 함수를 호출하기 때문이다   
클래스가 해당 클래스를 리시버 타입으로 갖는 확장 함수와 동일한 멤버 함수를 가진 경우,   
항상 멤버 함수가 이긴다
```
class C {
  fun foo() {println("member")}
}
fun C.foo() {println("extension")}
```
C의 모든 c에 대해 c.foo() 호출은 "extension"이 아닌 "member"출력

하지만 멤버 함수와 이름이 같지만 다른 시그너처를 갖도록 오버로딩한 확장 함수는 완전히 괜찮다
```
class	C	{				
  fun	foo()	{	println("member")	} 
}
fun	C.foo(i:	Int)	{	println("extension")	}
```
C().foo(1)	는 "extension"을 출력한다
## null 기능 리시버
확장이 null 가능 리시버 타입을 가질 수 있도록 정의할 수 있다   
이 확장은 객체 변수가 null인 경우에도 호출할 수 있고, 몸체 안에서 this	==	null로 이를 검사할 수 있다   
이는 코틀린에서 null 검사 없이 toString()을 호출할 수 있도록 한다 / 확장 함수 안에서 이 검사를 한다
```
fun Any?.toString(): String {
  if(this == null) return "null"
  // null검사 후에 'this'는 자동으로 non-null타입으로 변환, 따라서 아래 toString()을
  // 모든 클래스의 멤버 함수로 처리
  return toString()
}
```
## 확장 프로퍼티
함수와 유사하게, 코틀린은 확장 프로퍼티를 지원
```
val <T> List<T>.lastIndex: Int
  get() = size - 1
```











































































